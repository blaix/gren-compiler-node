{"CLI.Parser":{"name":"CLI.Parser","comment":" A module for parsing arguments from the command line. With this you can turn the following\n\n   mycmd greet --overwrite file.txt\n\nInto a data structure.\n\n* `mycmd` is the [Application](#App)\n* `greet` is the [Command](#Command)\n* `--overwrite` is a [Flag](#FlagParser)\n* `file.txt` is an [Argument](#ArgumentParser)\n\n## Application\n\n@docs App, run\n\n## Groups\n\n@docs GroupParser, Command, CommandParseResult, defineGroup, withCommand, withPrefix\n\n## Arguments\n\n@docs ValueParser, ArgumentParser, ArgumentParserError, argumentErrorPrettified, noArgs, oneArg, twoArgs, threeArgs, zeroOrMoreArgs, mapArgs, oneOfArgs\n\n## Flags\n\n@docs FlagParser, FlagParserError, flagErrorPrettified, noFlags, initFlags, toggle, flag\n\n## Common parsers\n\n@docs pathParser, grenFileParser\n","unions":[{"name":"ArgumentParser","comment":" Arguments are values that a [Command](#Command) requires to function. An `ArgumentParser`\nis a way of converting an arbitrary number of `String` inputs into Gren values.\n","args":["val"],"cases":[]},{"name":"ArgumentParserError","comment":" There are mainly two things that can go wrong when parsing arguments. You can either get an\nunexpected number of arguments or one or more of those arguments may fail to parse.\n","args":[],"cases":[["ArgumentParserWrongArity",["{ expected : Basics.Int, actual : Basics.Int }"]],["ArgumentParserInvalidArgument",["{ argument : String.String, title : String.String, examples : Array.Array String.String }"]]]},{"name":"CommandParseResult","comment":" The result of parsing user input.\n","args":["a"],"cases":[["UnknownCommand",["String.String"]],["BadFlags",["CLI.Parser.FlagParserError"]],["BadArguments",["CLI.Parser.ArgumentParserError"]],["HelpText",["CLI.PrettyPrinter.Document"]],["Success",["a"]]]},{"name":"FlagParser","comment":" Flags are prefixed with `--` and are meant to customize a command.\n","args":["val"],"cases":[]},{"name":"FlagParserError","comment":" There are several things that can go wrong when parsing flags:\n\n* The parser can find an associated value for a flag that requires none.\n* The parser might not find an associated value for a flag that does require one.\n* The associated value might fail to parse.\n* The flag might be unknown.\n","args":[],"cases":[["FlagParserFoundValueOnToggle",["CLI.Parser.KnownFlags","String.String"]],["FlagParserMissingValue",["CLI.Parser.KnownFlags","String.String"]],["FlagParserInvalidValue",["CLI.Parser.KnownFlags","String.String"]],["FlagParserUnknownFlag",["CLI.Parser.KnownFlags","String.String"]]]},{"name":"GroupParser","comment":" A parser for a group, or collection, of commands.\n","args":["result"],"cases":[]}],"aliases":[{"name":"App","comment":" Defines a command line application.\n\n* `name` is the name of the application\n* `version` is the application version\n* `commands` is a group of commands that this application recognizes\n* `intro` and `outro` is used when the user calls the application without\nany arguments. They define what text comes before and after the list of\nsupported commands.\n","args":["result"],"type":"{ name : String.String, version : String.String, commands : CLI.Parser.GroupParser result, intro : CLI.PrettyPrinter.Document, outro : CLI.PrettyPrinter.Document }"},{"name":"Command","comment":" Definition of a command.\n","args":["args","flags","result"],"type":"{ word : String.String, arguments : CLI.Parser.ArgumentParser args, flags : CLI.Parser.FlagParser flags, commonDescription : Maybe.Maybe String.String, summary : String.String, example : CLI.PrettyPrinter.Document, builder : args -> flags -> result }"},{"name":"ValueParser","comment":" Defines an argument value. The `fn` property is the function that parses\nthe `String` representation of an argument into its final form.\n","args":["val"],"type":"{ singular : String.String, plural : String.String, fn : String.String -> Maybe.Maybe val, examples : Array.Array String.String }"}],"values":[{"name":"argumentErrorPrettified","comment":" Turns an [ArgumentParserError](#ArgumentParserError) into a prettified `String`.\n","type":"CLI.Parser.ArgumentParserError -> CLI.PrettyPrinter.Document"},{"name":"defineGroup","comment":" Defines an empty group of commands. To add commands to this group, you'll\nneed to use [withCommand](#withCommand) and [withPrefix](#withPrefix).\n","type":"CLI.Parser.GroupParser result"},{"name":"flag","comment":" Defines a flag that requires an associated value.\n","type":"String.String -> CLI.Parser.ValueParser a -> String.String -> CLI.Parser.FlagParser (Maybe.Maybe a -> b) -> CLI.Parser.FlagParser b"},{"name":"flagErrorPrettified","comment":" Returns a prettified error message for the given [FlagParserError](#FlagParserError).\n","type":"CLI.Parser.FlagParserError -> CLI.PrettyPrinter.Document"},{"name":"grenFileParser","comment":" Like [pathParser](#pathParser), but verifies that the file extension is `.gren`.\n","type":"CLI.Parser.ValueParser FileSystem.Path.Path"},{"name":"initFlags","comment":" Defines an empty group of flags. You'll need to register flags using the\n[toggle](#toggle) and [flag](#flag) functions.\n","type":"a -> CLI.Parser.FlagParser a"},{"name":"mapArgs","comment":" Maps a successfully parsed set of arguments into something else.\n","type":"(a -> b) -> CLI.Parser.ArgumentParser a -> CLI.Parser.ArgumentParser b"},{"name":"noArgs","comment":" Some [Command](#Command)s doesn't require arguments. This parser checks that exactly 0\narguments were provided.\n","type":"CLI.Parser.ArgumentParser {}"},{"name":"noFlags","comment":" A parser that verifies that no flags have been provided.\n","type":"CLI.Parser.FlagParser {}"},{"name":"oneArg","comment":" Parses exactly one argument.\n","type":"CLI.Parser.ValueParser val -> CLI.Parser.ArgumentParser val"},{"name":"oneOfArgs","comment":" A list of parsers that will be tried one after another until one\nsucceeds.\n","type":"Array.Array (CLI.Parser.ArgumentParser val) -> CLI.Parser.ArgumentParser val"},{"name":"pathParser","comment":" Parses a `String` into a `FileSystem.Path`.\n","type":"CLI.Parser.ValueParser FileSystem.Path.Path"},{"name":"run","comment":" Takes input from the user in the form of an `Array` of `String`, and parses it according\nto the given `App` definition.\n","type":"Array.Array String.String -> CLI.Parser.App result -> CLI.Parser.CommandParseResult result"},{"name":"threeArgs","comment":" Parses exactly three arguments.\n","type":"(a -> b -> c -> d) -> CLI.Parser.ValueParser a -> CLI.Parser.ValueParser b -> CLI.Parser.ValueParser c -> CLI.Parser.ArgumentParser d"},{"name":"toggle","comment":" Defines a flag that doesn't require an associated value. We're simply checking\nif the flag is present or not.\n","type":"String.String -> String.String -> CLI.Parser.FlagParser (Basics.Bool -> b) -> CLI.Parser.FlagParser b"},{"name":"twoArgs","comment":" Parses exactly two arguments.\n","type":"(a -> b -> c) -> CLI.Parser.ValueParser a -> CLI.Parser.ValueParser b -> CLI.Parser.ArgumentParser c"},{"name":"withCommand","comment":" Returns a new group that contains the given command. If there are multiple\ncommands in the group with the same `word`, then the last registered command\nwins.\n","type":"CLI.Parser.Command args flags result -> CLI.Parser.GroupParser result -> CLI.Parser.GroupParser result"},{"name":"withPrefix","comment":" Embeds a group of commands into an existing group, accessible by the given prefix.\n","type":"String.String -> CLI.Parser.GroupParser result -> CLI.Parser.GroupParser result -> CLI.Parser.GroupParser result"},{"name":"zeroOrMoreArgs","comment":" Parses zero or more arguments of a single type.\n","type":"CLI.Parser.ValueParser val -> CLI.Parser.ArgumentParser (Array.Array val)"}],"binops":[]},"CLI.PrettyPrinter":{"name":"CLI.PrettyPrinter","comment":" This module lets you define how text should be formatted before printing\nit to the terminal.\n\n@docs Document\n@docs empty, text, words, indent, block, verticalBlock\n@docs Color, color, intenseColor, stripColor\n@docs toString, ToStringOptions, defaultOptions, toStringWithOptions\n","unions":[{"name":"Color","comment":" Supported text colors\n","args":[],"cases":[["Black",[]],["Red",[]],["Green",[]],["Yellow",[]],["Blue",[]],["Magenta",[]],["Cyan",[]],["White",[]]]},{"name":"Document","comment":" A `Document` represents formatted text.\n","args":[],"cases":[]}],"aliases":[{"name":"ToStringOptions","comment":" Different settings when converting a [Document](#Document) into `String`.\n\n* `maxColumns` defines the maximum number of characters in a line.\n* `indentationSize` defines the number of spaces per indentation level.\n* `newlineSeparator` defines the `String` used for representing newlines.\n","args":[],"type":"{ maxColumns : Basics.Int, indentationSize : Basics.Int, newlineSeparator : String.String }"}],"values":[{"name":"block","comment":" This joins multiple [Documents](#Document) into one. If possible, everything\nwill be placed on a single line.\n","type":"Array.Array CLI.PrettyPrinter.Document -> CLI.PrettyPrinter.Document"},{"name":"color","comment":" Colorize the text in the given [Document](#Document).\n","type":"CLI.PrettyPrinter.Color -> CLI.PrettyPrinter.Document -> CLI.PrettyPrinter.Document"},{"name":"defaultOptions","comment":" A default set of options for converting [Document](#Document) into `String`.\n","type":"CLI.PrettyPrinter.ToStringOptions"},{"name":"empty","comment":" The empty [Document](#Document) takes up no space. It's analogous to the\nempty `String`.\n","type":"CLI.PrettyPrinter.Document"},{"name":"indent","comment":" The contents of the [Document](#Document) is indented one level.\n","type":"CLI.PrettyPrinter.Document -> CLI.PrettyPrinter.Document"},{"name":"intenseColor","comment":" Like [color](#color), but intensifies the given color.\n","type":"CLI.PrettyPrinter.Color -> CLI.PrettyPrinter.Document -> CLI.PrettyPrinter.Document"},{"name":"stripColor","comment":" This removes all colorized text in a [Document](#Document).\n","type":"CLI.PrettyPrinter.Document -> CLI.PrettyPrinter.Document"},{"name":"text","comment":" Turn a `String` into a [Document](#Document). Newlines are not respected,\nif you want to spread text over multiple lines, use [verticalBlock](#verticalBlock).\n\nWord boundaries are also not respected. If that's important to you, you might want\nto use [words](#words)\n","type":"String.String -> CLI.PrettyPrinter.Document"},{"name":"toString","comment":" Convert a [Document](#Document) into a `String` that's ready to be written\nto the terminal.\n","type":"CLI.PrettyPrinter.Document -> String.String"},{"name":"toStringWithOptions","comment":" Like [toString](#toString), but allows you to override the default options.\n","type":"CLI.PrettyPrinter.ToStringOptions -> CLI.PrettyPrinter.Document -> String.String"},{"name":"verticalBlock","comment":" Like [block](#block), but each [Document](#Document) is placed on a seperate line.\n","type":"Array.Array CLI.PrettyPrinter.Document -> CLI.PrettyPrinter.Document"},{"name":"words","comment":" Similar to [text](#text), but word boundaries are respected if the `String` has\nto be broken up over multiple lines. Whitespace between words are reduced to a single\nspace.\n","type":"String.String -> CLI.PrettyPrinter.Document"}],"binops":[]},"CompilerBlob":{"name":"CompilerBlob","comment":" Functions for working with the Haskell-based Gren compiler.\n\n@docs version\n\n@docs UnsupportedPlatform, downloadUrl, download, cachePath, isCached\n\n@docs Command, InitFlags, ReplFlags, MakeFlags, MakeOutput, DocsFlags, DocsOutput, DiffArgs, Platform, run\n\n","unions":[{"name":"Command","comment":" Commands supported by the compiler blob.\n\n* `Init`: generate a gren.json and src directory in the current directory.\n* `Repl`: run a REPL.\n* `Make`: compile a project\n* `Docs`: generate a docs.json file\n* `PackageInstall`: install dependencies\n* `PackageUninstall`: remove a dependency\n* `PackageOutdated`: get a list of outdated dependencies\n* `PackageValide`: check if this package is ready to be deployed\n* `PackageBump`: bump package version to next compatible semantic version\n* `PackageDiff`: calculate the API-difference between this package and another version.\n","args":[],"cases":[["Init",["CompilerBlob.InitFlags"]],["Repl",["CompilerBlob.ReplFlags"]],["Make",["CompilerBlob.MakeFlags","Array.Array FileSystem.Path.Path"]],["Docs",["CompilerBlob.DocsFlags"]],["PackageInstall",["Maybe.Maybe Package.Package"]],["PackageUninstall",["Package.Package"]],["PackageOutdated",[]],["PackageValidate",[]],["PackageBump",[]],["PackageDiff",["CompilerBlob.DiffArgs"]]]},{"name":"DiffArgs","comment":"","args":[],"cases":[["DiffLatest",[]],["DiffVersion",["SemanticVersion.SemanticVersion"]],["DiffRange",["SemanticVersion.SemanticVersion","SemanticVersion.SemanticVersion"]],["DiffGlobal",["Package.Package","SemanticVersion.SemanticVersion","SemanticVersion.SemanticVersion"]]]},{"name":"DocsOutput","comment":"","args":[],"cases":[["DocsStdOut",[]],["DocsDevNull",[]],["DocsJson",["String.String"]]]},{"name":"MakeOutput","comment":"","args":[],"cases":[["StdOut",[]],["DevNull",[]],["Html",["String.String"]],["Js",["String.String"]],["Exe",["String.String"]]]},{"name":"Platform","comment":"","args":[],"cases":[["Common",[]],["Browser",[]],["Node",[]]]},{"name":"UnsupportedPlatform","comment":" Type used to signal that the given platform isn't supported. Meaning that there doesn't exist\na pre-built compiler blob.\n","args":[],"cases":[["UnsupportedPlatform",[]]]}],"aliases":[{"name":"DocsFlags","comment":"","args":[],"type":"{ output : Maybe.Maybe CompilerBlob.DocsOutput, report : Maybe.Maybe {} }"},{"name":"InitFlags","comment":"","args":[],"type":"{ package : Basics.Bool, platform : CompilerBlob.Platform }"},{"name":"MakeFlags","comment":"","args":[],"type":"{ optimize : Basics.Bool, sourcemaps : Basics.Bool, output : Maybe.Maybe CompilerBlob.MakeOutput, report : Maybe.Maybe {} }"},{"name":"ReplFlags","comment":"","args":[],"type":"{ interpreter : Maybe.Maybe String.String }"}],"values":[{"name":"cachePath","comment":" Construct a `Path` where we'd expect to find the compiler blob if it has been downloaded\npreviously.\n","type":"Node.Platform -> Dict.Dict String.String String.String -> FileSystem.Path.Path -> FileSystem.Path.Path"},{"name":"download","comment":" Downlod the compiler blob.\n","type":"HttpClient.Permission -> String.String -> Task.Task (HttpClient.Error Bytes.Bytes) (HttpClient.Response Bytes.Bytes)"},{"name":"downloadUrl","comment":" Construct a URL from which you can download a compiler blob compatible with the given\nplatform and cpu architecture.\n","type":"Node.Platform -> Node.CpuArchitecture -> Result.Result CompilerBlob.UnsupportedPlatform String.String"},{"name":"isCached","comment":" Checks if the compiler blob exist on this system.\n","type":"FileSystem.Permission -> Node.Platform -> Dict.Dict String.String String.String -> FileSystem.Path.Path -> Task.Task x Basics.Bool"},{"name":"run","comment":" Execute the compiler blob. The blob will write to stdout and stderr. There's currently no way\nto redirect what is written to these streams.\n","type":"ChildProcess.Permission -> CompilerBlob.RunOptions msg -> Platform.Cmd.Cmd msg"},{"name":"version","comment":" Version of the compiler blob. This might not match the version of the Gren compiler as a whole,\nas the Haskell- and Gren-parts are versioned seperatly.\n","type":"String.String"}],"binops":[]},"Package":{"name":"Package","comment":" Functions for working with package identifiers.\n\n@docs Package, author, name, fromString, cliParser, toString, toJson\n","unions":[{"name":"Package","comment":" A package is identified by a string in the following format:\n\n    author/name\n\nWhere `author` represents the person, or organization, that built the package, and\n`name` is... well, a name. A name should ideally describe the purpose of the package.\n\nBoth `author` and `name` can contain alphanumeric characters and a single dash as a seperator,\nbut no other characters.\n","args":[],"cases":[]}],"aliases":[],"values":[{"name":"author","comment":" Retrieve the package author.\n","type":"Package.Package -> String.String"},{"name":"cliParser","comment":" A parser for use with [CLI.Parser](#CLI.Parser).\n","type":"CLI.Parser.ValueParser Package.Package"},{"name":"fromString","comment":" Attempt to convert a `String` into [Package](#Package).\n","type":"String.String -> Maybe.Maybe Package.Package"},{"name":"name","comment":" Retrieve the package name.\n","type":"Package.Package -> String.String"},{"name":"toJson","comment":" Turn [Package](#Package) into `Json`.\n","type":"Package.Package -> Json.Encode.Value"},{"name":"toString","comment":" Turn [Package](#Package) into a `String`.\n","type":"Package.Package -> String.String"}],"binops":[]},"SemanticVersion":{"name":"SemanticVersion","comment":" Semantic versions consist of three numbers, each having a specific\nmeaning. This module makes no attempt to enforce the semantic versioning\nrules.\n\n@docs SemanticVersion, fromString, cliParser, toString, toJson\n","unions":[],"aliases":[{"name":"SemanticVersion","comment":" A semantic version has three numbers, separated by a period.\n\n* `major` signifies API compatibility. Two version with different `major` numbers, are likely\nincompatible.\n* `minor` represents additions. `1.0.0` should be compatible with `1.1.0`, but not the other way around.\n* `patch` represents bug fixes. `1.0.0` and `1.0.1` has the same API, but the latter might be more stable.\n","args":[],"type":"{ major : Basics.Int, minor : Basics.Int, patch : Basics.Int }"}],"values":[{"name":"cliParser","comment":" A parser for use with [CLI.Parser](#CLI.Parser).\n","type":"CLI.Parser.ValueParser SemanticVersion.SemanticVersion"},{"name":"fromString","comment":" Convert a `String` into a [SemanticVersion](#SemanticVersion).\n","type":"String.String -> Maybe.Maybe SemanticVersion.SemanticVersion"},{"name":"toJson","comment":" Turn a [SemanticVersion](#SemanticVersion) into `Json`.\n","type":"SemanticVersion.SemanticVersion -> Json.Encode.Value"},{"name":"toString","comment":" Turn a [SemanticVersion](#SemanticVersion) into a `String`.\n","type":"SemanticVersion.SemanticVersion -> String.String"}],"binops":[]}}