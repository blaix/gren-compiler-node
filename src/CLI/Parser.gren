module CLI.Parser exposing 
    ( App
    --
    , GroupParser
    , defineGroup
    , withCommand
    , withPrefix
    , run
    --
    , Command
    , CommandParseResult(..)
    --
    , ValueParser
    --
    , ArgumentParser
    , ArgumentParserError(..)
    , noArgs
    , oneArg
    , twoArgs
    , threeArgs
    , zeroOrMoreArgs
    , mapArgs
    , oneOfArgs
    --
    , FlagParser
    , FlagParserError(..)
    , noFlags
    , initFlags
    , toggle
    , flag
    --
    , pathParser
    , grenFileParser
    )


import Dict exposing (Dict)
import FileSystem.Path as Path exposing (Path)
import CLI.PrettyPrinter as PP


type alias App result =
    { name : String
    , version : String
    , intro : PP.Document
    , outro : PP.Document
    , commands : GroupParser result
    }


type GroupParser result
    = GroupParser 
        (Dict String (Maybe String))
        (String -> String -> Array String -> Dict String String -> CommandParseResult result)


defineGroup : GroupParser result
defineGroup =
    GroupParser Dict.empty <| \_appName name _args _flags ->
        UnknownCommand name


withCommand : Command args flags result -> GroupParser result -> GroupParser result
withCommand command (GroupParser knownCommands next) =
    GroupParser (Dict.set command.word command.commonDescription knownCommands) <| \appName name args flags ->
        if name /= command.word then
            next appName name args flags

        else
            runCommand appName args flags command


withPrefix : String -> GroupParser result -> GroupParser result -> GroupParser result
withPrefix prefix prefixedCommands (GroupParser knownCommands nextCommand) =
    GroupParser (Dict.set prefix Nothing knownCommands) <| \appName name args flags ->
        if name /= prefix then
            nextCommand appName name args flags

        else
            runPrefix appName prefix args flags prefixedCommands


run : Array String -> App result -> CommandParseResult result
run tokens appDef =
    let
        (GroupParser _ parse) =
            appDef.commands
        
        { trues = flags, falses = arguments } =
            Array.partition (\word -> String.startsWith "--" word) tokens
    in
    case flags of
        [ "--version" ] ->
            HelpText <| PP.text appDef.version
        
        _ ->
            case Array.popFirst arguments of
                Just { first = command, rest = args } ->
                    parse appDef.name command args (buildFlagDict flags)

                Nothing ->
                    HelpText <| appHelpText appDef


appHelpText : App result -> PP.Document
appHelpText appDef =
    let
        (GroupParser knownCommands _) =
            appDef.commands
        
        commonCommands =
            knownCommands
                |> Dict.filterMap (\_name commonDescription -> commonDescription)

        knownCommandsDocument =
            PP.verticalBlock
                [ knownCommands
                    |> Dict.keys
                    |> Array.map (\command -> PP.text <| appDef.name ++ " " ++ command)
                    |> PP.verticalBlock
                    |> PP.indent
                    |> PP.color PP.Cyan
                , PP.empty
                , PP.block
                    [ PP.text "Adding the "
                    , PP.color PP.Cyan <| PP.text "--help"
                    , PP.text " flag gives you more details about a specific command."
                    ]
                ]

        commandBlock =
            if Dict.isEmpty commonCommands then
                PP.verticalBlock
                    [ PP.words "In order to do something useful, you need to give me a command. Here's a full list:"
                    , PP.empty
                    , knownCommandsDocument
                    ]
            else
                PP.verticalBlock
                    [ PP.words "The most common commands are:"
                    , PP.empty
                    , commonCommands
                        |> Dict.foldl
                            (\name description acc ->
                                Array.pushLast
                                    (PP.verticalBlock
                                        [ PP.intenseColor PP.Cyan <| PP.text (appDef.name ++ " " ++ name)
                                        , PP.indent <|
                                            PP.words description
                                        , PP.empty
                                        ]
                                    )
                                    acc
                            )
                            []
                        |> PP.verticalBlock
                        |> PP.indent
                    , PP.words "There are a bunch of other commands as well though. Here is a full list:"
                    , PP.empty
                    , knownCommandsDocument
                    ]
    in
    PP.verticalBlock
        [ appDef.intro
        , PP.empty
        , commandBlock
        , PP.empty
        , appDef.outro
        , PP.empty
        ]


runPrefix : String -> String -> Array String -> Dict String String -> GroupParser result -> CommandParseResult result
runPrefix appName prefixName arguments flags ((GroupParser _ parse) as groupParser) =
    case Array.popFirst arguments of
        Just { first = command, rest = args } ->
            parse appName command args flags

        Nothing ->
            HelpText <| prefixHelpText appName prefixName groupParser


prefixHelpText : String -> String -> GroupParser result -> PP.Document
prefixHelpText appName prefixName (GroupParser knownCommands _) =
    let
        knownCommandsDocument =
            PP.verticalBlock
                [ knownCommands
                    |> Dict.keys
                    |> Array.map (\command -> PP.text <| appName ++ " " ++ prefixName ++ " " ++ command)
                    |> PP.verticalBlock
                    |> PP.indent
                    |> PP.color PP.Cyan
                , PP.empty
                , PP.block
                    [ PP.text "Adding the "
                    , PP.color PP.Cyan <| PP.text "--help"
                    , PP.text " flag gives you more details about a specific command."
                    ]
                ]
    in
    PP.verticalBlock
        [ PP.words "This is just a prefix. In order to do something useful, you need to give me a command. Here's a full list:"
        , PP.empty
        , knownCommandsDocument
        , PP.empty
        ]

buildFlagDict : Array String -> Dict String String
buildFlagDict flags =
    Array.foldl
        (\rawFlag dict ->
            let
                flagParts =
                    rawFlag
                        |> String.dropLeft 2 -- the --prefix            
                        |> String.split "="
                        |> Array.takeFirst 2
            in
            case flagParts of
                [ key ] ->
                    Dict.set key "" dict

                [ key, value ] ->
                    Dict.set key value dict

                _ ->
                    dict
        )
        Dict.empty
        flags


-- COMMAND


type alias Command args flags result =
    { word : String
    , arguments : ArgumentParser args
    , flags : FlagParser flags
    , commonDescription : Maybe String
    , summary : String
    , example : PP.Document
    , builder : args -> flags -> result
    }


type CommandParseResult a
    = UnknownCommand String
    | BadFlags FlagParserError
    | BadArguments ArgumentParserError
    | HelpText PP.Document
    | Success a


runCommand : String -> Array String -> Dict String String -> Command args flags result -> CommandParseResult result
runCommand appName args flags spec =
    let
        (ArgumentParser _ parseArgs) =
            spec.arguments
    
        (FlagParser _ parseFlags) =
            spec.flags
    in
    case 
        { argResult = parseArgs args
        , flagResult = parseFlags flags
        }
    of
        { argResult = Ok argValue, flagResult = Ok flagValues } ->
            Success <| spec.builder argValue flagValues
    
        { argResult = Err err } ->
            BadArguments err
    
        { flagResult = Err err } ->
            case err of
                FlagParserUnknownFlag "help" ->
                    HelpText <| commandHelpText appName spec

                _ ->
                    BadFlags err


commandHelpText : String -> Command args flags result -> PP.Document
commandHelpText appName spec =
    let
        (ArgumentParser argumentType _) =
            spec.arguments
        
        (FlagParser knownFlags _) =
            spec.flags

        flagDocument =
            Dict.foldl
                (\flagName flagDescription acc ->
                    let
                        flagSuffix =
                            if flagDescription.title == "" then
                                ""

                            else
                                "=<" ++ flagDescription.title ++ ">"
                    in
                    Array.prepend acc
                        [ PP.text ("--" ++ flagName ++ flagSuffix)
                            |> PP.color PP.Cyan
                        , PP.words flagDescription.description
                            |> PP.indent
                        , PP.empty
                        ]
                )
                []
                knownFlags
                |> PP.verticalBlock
                |> PP.indent

        commandSuffix =
            if argumentType == "" then
                ""

            else
                " <" ++ argumentType ++ ">"
    in
    PP.verticalBlock
        [ PP.words spec.summary
        , PP.empty
        , PP.words (appName ++ " " ++ spec.word ++ commandSuffix)
            |> PP.indent
            |> PP.color PP.Cyan
        , PP.empty
        , spec.example
        , PP.empty
        , PP.words "You can customize this command with the following flags:"
        , PP.empty
        , flagDocument
        ]


-- ARGS


type ArgumentParser val
    = ArgumentParser String (Array String -> Result ArgumentParserError val)


type alias ValueParser val =
    { singular : String
    , plural : String
    , fn : (String -> Maybe val)
    }


type ArgumentParserError
    = ArgumentParserWrongArity { expected : Int, actual : Int }
    | ArgumentParserInvalidArgument


noArgs : ArgumentParser {}
noArgs =
    ArgumentParser "" <| \args ->
        if Array.length args /= 0 then
            Err <| ArgumentParserWrongArity { expected = 0, actual = (Array.length args) }

        else
            Ok {}


oneArg : ValueParser val -> ArgumentParser val
oneArg parseFn =
    ArgumentParser parseFn.singular <| \args ->
        case args of
            [ arg ] ->
                parseFn.fn arg
                    |> Maybe.map Ok
                    |> Maybe.withDefault (Err ArgumentParserInvalidArgument)

            _ ->
                Err <| ArgumentParserWrongArity { expected = 1, actual = Array.length args }


twoArgs : (a -> b -> c) -> ValueParser a -> ValueParser b -> ArgumentParser c
twoArgs combine firstValue secondValue =
    ArgumentParser (firstValue.singular ++ "-" ++ secondValue.singular) <| \args ->
        case args of
            [ first, second ] ->
                case { first = firstValue.fn first, second = secondValue.fn second } of
                    { first = Just firstOk, second = Just secondOk } ->
                        Ok <| combine firstOk secondOk

                    { first = Nothing } ->
                        Err ArgumentParserInvalidArgument
                    
                    { second = Nothing } ->
                        Err ArgumentParserInvalidArgument

            _ ->
                Err <| ArgumentParserWrongArity { expected = 2, actual = Array.length args }


threeArgs : (a -> b -> c -> d) -> ValueParser a -> ValueParser b -> ValueParser c -> ArgumentParser d
threeArgs combine firstValue secondValue thirdValue =
    ArgumentParser (String.join "-" [firstValue.singular, secondValue.singular, thirdValue.singular]) <| \args ->
        case args of
            [ first, second, third ] ->
                case { first = firstValue.fn first, second = secondValue.fn second, third = thirdValue.fn third } of
                    { first = Just firstOk, second = Just secondOk, third = Just thirdOk } ->
                        Ok <| combine firstOk secondOk thirdOk

                    { first = Nothing } ->
                        Err ArgumentParserInvalidArgument
                    
                    { second = Nothing } ->
                        Err ArgumentParserInvalidArgument

                    { third = Nothing } ->
                        Err ArgumentParserInvalidArgument

            _ ->
                Err <| ArgumentParserWrongArity { expected = 3, actual = Array.length args }


zeroOrMoreArgs : ValueParser val -> ArgumentParser (Array val)
zeroOrMoreArgs parseFn =
    ArgumentParser parseFn.plural <| \args ->
        let
            parsedArgs =
                Array.filterMap parseFn.fn args
        in
        if Array.length args /= Array.length parsedArgs then
            Err ArgumentParserInvalidArgument

        else
            Ok parsedArgs


mapArgs : (a -> b) -> ArgumentParser a -> ArgumentParser b
mapArgs mapper (ArgumentParser desc fn) =
    ArgumentParser desc <| \args ->
        case fn args of
            Ok val ->
                Ok (mapper val)

            Err err ->
                Err err


oneOfArgs : Array (ArgumentParser val) -> ArgumentParser val
oneOfArgs argParsers =
    ArgumentParser "<one-of>" <| \args ->
        let
            parseResults =
                Array.map (\(ArgumentParser _ fn) -> fn args) argParsers
        in
        case Result.firstOk parseResults of
            Just result ->
                Ok result

            Nothing ->
                Array.first parseResults
                    |> Maybe.withDefault (Err ArgumentParserInvalidArgument)


-- FLAGS


type FlagParser val
    = FlagParser (Dict String FlagParserDescription) (Dict String String -> Result FlagParserError val)


type alias FlagParserDescription =
    { title : String
    , description : String
    }


type FlagParserError
    = FlagParserFoundValueOnToggle
    | FlagParserMissingValue
    | FlagParserInvalidValue
    | FlagParserUnknownFlag String


noFlags : FlagParser {}
noFlags =
    initFlags {}


initFlags : a -> FlagParser a
initFlags value =
    FlagParser Dict.empty <| \remainingFlags -> 
        case Dict.first remainingFlags of
            Just unparsedFlag ->
                Err <| FlagParserUnknownFlag unparsedFlag.key

            Nothing ->
                Ok value


toggle : String -> String -> FlagParser (Bool -> b) -> FlagParser b
toggle key desc (FlagParser knownFlags previousSteps) =
    let
        descriptor =
            { title = ""
            , description = desc
            }
    in
    FlagParser (Dict.set key descriptor knownFlags) <| \opts ->
        case previousSteps (Dict.remove key opts) of
            Ok next ->
                case Dict.get key opts of
                    Just "" ->
                        Ok (next True)

                    Just _ ->
                        Err FlagParserFoundValueOnToggle

                    Nothing ->
                        Ok (next False)

            Err err ->
                Err err

flag : String -> ValueParser a -> String -> FlagParser (Maybe a -> b) -> FlagParser b
flag key valueParserFn desc (FlagParser knownFlags previousSteps) =
    let
        descriptor =
            { title = valueParserFn.singular
            , description = desc
            }
    in
    FlagParser (Dict.set key descriptor knownFlags) <| \opts ->
        case previousSteps (Dict.remove key opts) of
            Ok next ->
                case Dict.get key opts of
                    Just "" ->
                        Err FlagParserMissingValue
                    
                    Just value ->
                        case valueParserFn.fn value of
                            Just parsedValue ->
                                Ok (next <| Just parsedValue)

                            Nothing ->
                                Err FlagParserInvalidValue

                    Nothing ->
                        Ok (next Nothing)

            Err err ->
                Err err


-- PARSERS


pathParser : ValueParser Path
pathParser =
    { singular = "path"
    , plural = "paths"
    , fn = Just << Path.fromPosixString
    }


grenFileParser : ValueParser Path
grenFileParser =
    { singular = "gren file"
    , plural = "gren files"
    , fn = \input ->
        pathParser.fn input
            |> Maybe.andThen
                (\path ->
                    if path.extension /= "gren" then
                        Nothing
                
                    else
                        Just path
                )
    }
