module CLI.Parser exposing 
    ( App
    --
    , GroupParser
    , defineGroup
    , withCommand
    , withPrefix
    , run
    --
    , Command
    , CommandParseResult(..)
    --
    , ArgumentParser
    , ArgumentParserError(..)
    , noArgs
    , oneArg
    , zeroOrMoreArgs
    --
    , FlagParser
    , FlagParserError(..)
    , noFlags
    , initFlags
    , toggle
    , flag
    --
    , pathParser
    , grenFileParser
    )


import Dict exposing (Dict)
import FileSystem.Path as Path exposing (Path)
import CLI.PrettyPrinter as PP


type alias App result =
    { name : String
    , version : String
    , intro : PP.Document
    , outro : PP.Document
    , commands : GroupParser result
    }


type GroupParser result
    = GroupParser 
        (Dict String (Maybe String))
        (String -> Array String -> Dict String String -> CommandParseResult result)


defineGroup : GroupParser result
defineGroup =
    GroupParser Dict.empty <| \name _args _flags ->
        UnknownCommand name


withCommand : Command args flags result -> GroupParser result -> GroupParser result
withCommand command (GroupParser knownCommands next) =
    GroupParser (Dict.set command.word command.commonDescription knownCommands) <| \name args flags ->
        if name /= command.word then
            next name args flags

        else
            runCommand args flags command


withPrefix : String -> GroupParser result -> GroupParser result -> GroupParser result
withPrefix prefix prefixedCommands (GroupParser knownCommands nextCommand) =
    GroupParser (Dict.set prefix Nothing knownCommands) <| \name args flags ->
        if name /= prefix then
            nextCommand name args flags

        else
            runPrefix args flags prefixedCommands


run : Array String -> App result -> CommandParseResult result
run tokens appDef =
    let
        (GroupParser _ parse) =
            appDef.commands
        
        { trues = flags, falses = arguments } =
            Array.partition (\word -> String.startsWith "--" word) tokens
    in
    case flags of
        [ "--version" ] ->
            HelpText <| PP.text appDef.version
        
        _ ->
            case Array.popFirst arguments of
                Just { first = command, rest = args } ->
                    parse command args (buildFlagDict flags)

                Nothing ->
                    HelpText <| appHelpText appDef


appHelpText : App result -> PP.Document
appHelpText appDef =
    let
        (GroupParser knownCommands _) =
            appDef.commands
        
        commonCommands =
            knownCommands
                |> Dict.filterMap (\_name commonDescription -> commonDescription)

        knownCommandsDocument =
            PP.verticalBlock
                [ knownCommands
                    |> Dict.keys
                    |> Array.map (\command -> PP.text <| appDef.name ++ " " ++ command)
                    |> PP.verticalBlock
                    |> PP.indent
                    |> PP.intenseColor PP.Cyan
                , PP.empty
                , PP.block
                    [ PP.text "Adding the "
                    , PP.color PP.Green <| PP.text "--help"
                    , PP.text " flag gives you more details about a specific command."
                    ]
                ]

        commandBlock =
            if Dict.isEmpty commonCommands then
                PP.verticalBlock
                    [ PP.text "In order to do something useful, you need to give me a command. Here's a full list:"
                    , PP.empty
                    , knownCommandsDocument
                    ]
            else
                PP.verticalBlock
                    [ PP.text "The most common commands are:"
                    , PP.empty
                    , commonCommands
                        |> Dict.foldl
                            (\name description acc ->
                                Array.pushLast
                                    (PP.verticalBlock
                                        [ PP.color PP.Cyan <| PP.text (appDef.name ++ " " ++ name)
                                        , PP.indent <|
                                            PP.text description
                                        ]
                                    )
                                    acc
                            )
                            []
                        |> PP.verticalBlock
                        |> PP.indent
                    , PP.empty
                    , PP.text "There are a bunch of other commands as well though. Here is a full list:"
                    , PP.empty
                    , knownCommandsDocument
                    ]
    in
    PP.verticalBlock
        [ appDef.intro
        , PP.empty
        , commandBlock
        , PP.empty
        , appDef.outro
        , PP.empty
        ]


runPrefix : Array String -> Dict String String -> GroupParser result -> CommandParseResult result
runPrefix arguments flags (GroupParser _ parse) =
    case Array.popFirst arguments of
        Just { first = command, rest = args } ->
            parse command args flags

        Nothing ->
            HelpText PP.empty


buildFlagDict : Array String -> Dict String String
buildFlagDict flags =
    Array.foldl
        (\rawFlag dict ->
            let
                flagParts =
                    rawFlag
                        |> String.dropLeft 2 -- the --prefix            
                        |> String.split "="
                        |> Array.takeFirst 2
            in
            case flagParts of
                [ key ] ->
                    Dict.set key "" dict

                [ key, value ] ->
                    Dict.set key value dict

                _ ->
                    dict
        )
        Dict.empty
        flags


-- COMMAND


type alias Command args flags result =
    { word : String
    , arguments : ArgumentParser args
    , flags : FlagParser flags
    , commonDescription : Maybe String
    , summary : String
    , example : PP.Document
    , builder : args -> flags -> result
    }


type CommandParseResult a
    = UnknownCommand String
    | BadFlags FlagParserError
    | BadArguments ArgumentParserError
    | HelpText PP.Document
    | Success a


runCommand : Array String -> Dict String String -> Command args flags result -> CommandParseResult result
runCommand args flags spec =
    let
        (ArgumentParser parseArgs) =
            spec.arguments
    
        (FlagParser _ parseFlags) =
            spec.flags
    in
    case 
        { argResult = parseArgs args
        , flagResult = parseFlags flags
        }
    of
        { argResult = Ok argValue, flagResult = Ok flagValues } ->
            Success <| spec.builder argValue flagValues
    
        { argResult = Err err } ->
            BadArguments err
    
        { flagResult = Err err } ->
            case err of
                FlagParserUnknownFlag "help" ->
                    -- TODO
                    HelpText PP.empty

                _ ->
                    BadFlags err


-- ARGS


type ArgumentParser val
    = ArgumentParser (Array String -> Result ArgumentParserError val)


type ArgumentParserError
    = ArgumentParserWrongArity { expected : Int, actual : Int }
    | ArgumentParserInvalidArgument


noArgs : val -> ArgumentParser val
noArgs value =
    ArgumentParser <| \args ->
        if Array.length args /= 0 then
            Err <| ArgumentParserWrongArity { expected = 0, actual = (Array.length args) }

        else
            Ok value


oneArg : (String -> Maybe val) -> ArgumentParser val
oneArg builder =
    ArgumentParser <| \args ->
        case args of
            [ arg ] ->
                builder arg
                    |> Maybe.map Ok
                    |> Maybe.withDefault (Err ArgumentParserInvalidArgument)

            _ ->
                Err <| ArgumentParserWrongArity { expected = 1, actual = Array.length args }


zeroOrMoreArgs : (String -> Maybe val) -> ArgumentParser (Array val)
zeroOrMoreArgs builder =
    ArgumentParser <| \args ->
        let
            parsedArgs =
                Array.filterMap builder args
        in
        if Array.length args /= Array.length parsedArgs then
            Err ArgumentParserInvalidArgument

        else
            Ok parsedArgs


-- FLAGS


type FlagParser val
    = FlagParser (Dict String String) (Dict String String -> Result FlagParserError val)


type FlagParserError
    = FlagParserFoundValueOnToggle
    | FlagParserMissingValue
    | FlagParserInvalidValue
    | FlagParserUnknownFlag String


noFlags : FlagParser {}
noFlags =
    initFlags {}


initFlags : a -> FlagParser a
initFlags value =
    FlagParser Dict.empty <| \remainingFlags -> 
        case Dict.first remainingFlags of
            Just unparsedFlag ->
                Err <| FlagParserUnknownFlag unparsedFlag.key

            Nothing ->
                Ok value


toggle : String -> String -> FlagParser (Bool -> b) -> FlagParser b
toggle key desc (FlagParser knownFlags previousSteps) =
    FlagParser (Dict.set key desc knownFlags) <| \opts ->
        case previousSteps (Dict.remove key opts) of
            Ok next ->
                case Dict.get key opts of
                    Just "" ->
                        Ok (next True)

                    Just _ ->
                        Err FlagParserFoundValueOnToggle

                    Nothing ->
                        Ok (next False)

            Err err ->
                Err err

flag : String -> (String -> Maybe a) -> String -> FlagParser (Maybe a -> b) -> FlagParser b
flag key valueParser desc (FlagParser knownFlags previousSteps) =
    FlagParser (Dict.set key desc knownFlags) <| \opts ->
        case previousSteps (Dict.remove key opts) of
            Ok next ->
                case Dict.get key opts of
                    Just "" ->
                        Err FlagParserMissingValue
                    
                    Just value ->
                        case valueParser value of
                            Just parsedValue ->
                                Ok (next <| Just parsedValue)

                            Nothing ->
                                Err FlagParserInvalidValue

                    Nothing ->
                        Ok (next Nothing)

            Err err ->
                Err err


-- PARSERS


pathParser : String -> Maybe Path
pathParser input =
    Just <| Path.fromPosixString input
        


grenFileParser : String -> Maybe Path
grenFileParser input =
    pathParser input
        |> Maybe.andThen
            (\path ->
                if path.extension /= "gren" then
                    Nothing
                
                else
                    Just path
            )
