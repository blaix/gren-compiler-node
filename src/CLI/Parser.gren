module CLI.Parser exposing 
    ( Group
    , GroupParser
    , defineGroup
    , withCommand
    , run
    --
    , Command
    , CommandParseError(..)
    --
    , ArgumentParser
    , ArgumentParserError(..)
    , noArgs
    , oneArg
    , zeroOrMoreArgs
    --
    , FlagParser
    , FlagParserError(..)
    , noFlags
    , initFlags
    , toggle
    , flag
    --
    , pathParser
    , grenFileParser
    )


import Dict exposing (Dict)
import FileSystem.Path as Path exposing (Path)


-- COMMAND GROUP (?)


type Group result
    = Group 
        { name : Maybe String
        , commands : GroupParser result
        }


type GroupParser result
    = GroupParser (String -> Array String -> Dict String String -> Result CommandParseError result)


defineGroup : Group result
defineGroup =
    Group
        { name = Nothing
        , commands = GroupParser <| \name _args _flags ->
            Err <| UnknownCommand name
        }


withCommand : Command args flags result -> Group result -> Group result
withCommand command (Group group) =
    let
        (GroupParser next) =
            group.commands
    in
    Group 
        { group | commands =
            GroupParser <| \name args flags ->
                if name /= command.word then
                    next name args flags
        
                else
                    runCommand args flags command
        }


run : Array String -> Group result -> Result CommandParseError result
run tokens (Group group) =
    let
        { trues = flags, falses = arguments } =
            Array.partition (\word -> String.startsWith "--" word) tokens

        (GroupParser parse) =
            group.commands
    in
    case Array.popFirst arguments of
        Just { first = command, rest = args } ->
            parse command args (buildFlagDict flags)

        Nothing ->
            Err NoCommandGiven


buildFlagDict : Array String -> Dict String String
buildFlagDict flags =
    Array.foldl
        (\rawFlag dict ->
            let
                flagParts =
                    rawFlag
                        |> String.dropLeft 2 -- the --prefix            
                        |> String.split "="
                        |> Array.takeFirst 2
            in
            case flagParts of
                [ key ] ->
                    Dict.set key "" dict

                [ key, value ] ->
                    Dict.set key value dict

                _ ->
                    dict
        )
        Dict.empty
        flags


-- COMMAND


type alias Command args flags result =
    { word : String
    , arguments : ArgumentParser args
    , flags : FlagParser flags
    , commonDescription : Maybe String
    , summary : String
    , example : String
    , builder : args -> flags -> result
    }


type CommandParseError
    = NoCommandGiven
    | UnknownCommand String
    | BadFlags FlagParserError
    | BadArguments ArgumentParserError


runCommand : Array String -> Dict String String -> Command args flags result -> Result CommandParseError result
runCommand args flags spec =
    let
        (ArgumentParser parseArgs) =
            spec.arguments
    
        (FlagParser _ parseFlags) =
            spec.flags
    in
    case 
        { argResult = parseArgs args
        , flagResult = parseFlags flags
        }
    of
        { argResult = Ok argValue, flagResult = Ok flagValues } ->
            Ok <| spec.builder argValue flagValues
    
        { argResult = Err err } ->
            Err <| BadArguments err
    
        { flagResult = Err err } ->
            Err <| BadFlags err


-- ARGS


type ArgumentParser val
    = ArgumentParser (Array String -> Result ArgumentParserError val)


type ArgumentParserError
    = ArgumentParserWrongArity { expected : Int, actual : Int }
    | ArgumentParserInvalidArgument


noArgs : val -> ArgumentParser val
noArgs value =
    ArgumentParser <| \args ->
        if Array.length args /= 0 then
            Err <| ArgumentParserWrongArity { expected = 0, actual = (Array.length args) }

        else
            Ok value


oneArg : (String -> Maybe val) -> ArgumentParser val
oneArg builder =
    ArgumentParser <| \args ->
        case args of
            [ arg ] ->
                builder arg
                    |> Maybe.map Ok
                    |> Maybe.withDefault (Err ArgumentParserInvalidArgument)

            _ ->
                Err <| ArgumentParserWrongArity { expected = 1, actual = Array.length args }


zeroOrMoreArgs : (String -> Maybe val) -> ArgumentParser (Array val)
zeroOrMoreArgs builder =
    ArgumentParser <| \args ->
        let
            parsedArgs =
                Array.filterMap builder args
        in
        if Array.length args /= Array.length parsedArgs then
            Err ArgumentParserInvalidArgument

        else
            Ok parsedArgs


-- FLAGS


type FlagParser val
    = FlagParser (Dict String String) (Dict String String -> Result FlagParserError val)


type FlagParserError
    = FlagParserFoundValueOnToggle
    | FlagParserMissingValue
    | FlagParserInvalidValue


noFlags : FlagParser {}
noFlags =
    FlagParser Dict.empty (\_ -> Ok {})


initFlags : a -> FlagParser a
initFlags value =
    FlagParser Dict.empty (\_ -> Ok value)


toggle : String -> String -> FlagParser (Bool -> b) -> FlagParser b
toggle key desc (FlagParser knownFlags previousSteps) =
    FlagParser (Dict.set key desc knownFlags) <| \opts ->
        case previousSteps opts of
            Ok next ->
                case Dict.get key opts of
                    Just "" ->
                        Ok (next True)

                    Just _ ->
                        Err FlagParserFoundValueOnToggle

                    Nothing ->
                        Ok (next False)

            Err err ->
                Err err

flag : String -> (String -> Maybe a) -> String -> FlagParser (Maybe a -> b) -> FlagParser b
flag key valueParser desc (FlagParser knownFlags previousSteps) =
    FlagParser (Dict.set key desc knownFlags) <| \opts ->
        case previousSteps opts of
            Ok next ->
                case Dict.get key opts of
                    Just "" ->
                        Err FlagParserMissingValue
                    
                    Just value ->
                        case valueParser value of
                            Just parsedValue ->
                                Ok (next <| Just parsedValue)

                            Nothing ->
                                Err FlagParserInvalidValue

                    Nothing ->
                        Ok (next Nothing)

            Err err ->
                Err err


-- PARSERS


pathParser : String -> Maybe Path
pathParser input =
    Just <| Path.fromPosixString input
        


grenFileParser : String -> Maybe Path
grenFileParser input =
    pathParser input
        |> Maybe.andThen
            (\path ->
                if path.extension /= "gren" then
                    Nothing
                
                else
                    Just path
            )
