module CLI.Parser exposing 
    ( Command
    , CommandParseError(..)
    , run
    --
    , ArgParser
    , noArgs
    , oneArg
    , zeroOrMoreArgs
    --
    , FlagParser
    , noFlags
    , initFlags
    , onOff
    , flag
    --
    , pathParser
    , grenFileParser
    )


import Dict exposing (Dict)
import FileSystem.Path as Path exposing (Path)


-- COMMAND


type alias Command args flags result =
    { word : String
    , arguments : ArgParser args
    , flags : FlagParser flags
    , commonDescription : Maybe String
    , summary : String
    , example : String
    , builder : args -> flags -> result
    }


type CommandParseError
    = NoCommandGiven
    | WrongCommand
    | BadFlags
    | BadArguments


run : Command args flags result -> Array String -> Result CommandParseError result
run spec tokens =
    let
        { trues = flags, falses = arguments } =
            Array.partition (\word -> String.startsWith "--" word) tokens
    in
    case Array.popFirst arguments of
        Just { first = command, rest = args } ->
            if command /= spec.word then
                Err WrongCommand

            else
                let
                    (ArgParser parseArgs) =
                        spec.arguments
                    
                    (FlagParser _ parseFlags) =
                        spec.flags
                in
                case 
                    { argResult = parseArgs args
                    , flagResult = parseFlags (buildFlagDict flags)
                    }
                of
                    { argResult = Ok argValue, flagResult = FlagParsingOk flagValues } ->
                        Ok <| spec.builder argValue flagValues
                    
                    { argResult = Err _ } ->
                        Err BadArguments
                    
                    { flagResult = FlagParsingErr } ->
                        Err BadFlags

        Nothing ->
            Err NoCommandGiven


buildFlagDict : Array String -> Dict String String
buildFlagDict flags =
    Array.foldl
        (\rawFlag dict ->
            let
                flagParts =
                    rawFlag
                        |> String.dropLeft 2 -- the --prefix            
                        |> String.split "="
                        |> Array.takeFirst 2
            in
            case flagParts of
                [ key ] ->
                    Dict.set key "" dict

                [ key, value ] ->
                    Dict.set key value dict

                _ ->
                    dict
        )
        Dict.empty
        flags


-- ARGS


type ArgParser val
    = ArgParser (Array String -> Result {} val)


noArgs : val -> ArgParser val
noArgs value =
    ArgParser <| \args ->
        if Array.length args /= 0 then
            Err {}

        else
            Ok value

oneArg : (String -> Result {} val) -> ArgParser val
oneArg builder =
    ArgParser <| \args ->
        case args of
            [ arg ] ->
                builder arg

            _ ->
                Err {}

zeroOrMoreArgs : (String -> Result {} val) -> ArgParser (Array val)
zeroOrMoreArgs builder =
    ArgParser <| \args ->
        let
            parsedArgs =
                Array.map builder args

            successfulArgs =
                Array.filterMap Result.toMaybe parsedArgs
        in
        if Array.length successfulArgs /= Array.length parsedArgs then
            Err {}

        else
            Ok successfulArgs


-- FLAGS


type FlagParser val
    = FlagParser (Dict String String) (Dict String String -> FlagParsingStep val)


type FlagParsingStep val
    = FlagParsingOk val
    | FlagParsingErr


noFlags : FlagParser {}
noFlags =
    FlagParser Dict.empty (\_ -> FlagParsingOk {})


initFlags : a -> FlagParser a
initFlags builder =
    FlagParser Dict.empty (\_ -> FlagParsingOk builder)


onOff : String -> String -> FlagParser (Bool -> b) -> FlagParser b
onOff key desc (FlagParser knownFlags previousSteps) =
    FlagParser (Dict.set key desc knownFlags) <| \opts ->
        case previousSteps opts of
            FlagParsingOk next ->
                case Dict.get key opts of
                    Just "" ->
                        FlagParsingOk (next True)

                    Just _ ->
                        FlagParsingErr

                    Nothing ->
                        FlagParsingOk (next False)

            FlagParsingErr ->
                FlagParsingErr

flag : String -> (String -> Result {} a) -> String -> FlagParser (Maybe a -> b) -> FlagParser b
flag key valueParser desc (FlagParser knownFlags previousSteps) =
    FlagParser (Dict.set key desc knownFlags) <| \opts ->
        case previousSteps opts of
            FlagParsingOk next ->
                case Dict.get key opts of
                    Just "" ->
                        FlagParsingErr
                    
                    Just value ->
                        case valueParser value of
                            Ok parsedValue ->
                                FlagParsingOk (next <| Just parsedValue)

                            Err _ ->
                                FlagParsingErr

                    Nothing ->
                        FlagParsingOk (next Nothing)

            FlagParsingErr ->
                FlagParsingErr


-- PARSERS


pathParser : String -> Result {} Path
pathParser input =
    Ok <| Path.fromPosixString input
        


grenFileParser : String -> Result {} Path
grenFileParser input =
    pathParser input
        |> Result.andThen
            (\path ->
                if path.extension /= "gren" then
                    Err {}
                else
                    Ok path
            )
