module Test.CLI.Parser exposing (tests)

import Expect exposing (Expectation)
import Test exposing (Test, describe, test)
import CLI.Parser as Parser
import CLI.PrettyPrinter as PP
import FileSystem.Path as Path




tests : Test
tests =
    describe "CLI Parser"
        [ test "Parses successfully" <| \{} -> 
            expectParseSuccess testCmd testArgs <| \_ ->
                Expect.pass
        , test "This particular test case even succeeds without args or flags" <| \{} ->
            expectParseSuccess testCmd ["make"] <| \_ ->
                Expect.pass
        , test "Passing --version returns the app version" <| \{} ->
            runCommand testCmd ["--version"]
                |> Expect.equal (Parser.HelpText <| PP.text testApp.version)
        , test "Passing --help prints help text" <| \{} ->
            let
                result =
                    runCommand testCmd ["--help"]
            in
            case result of
                Parser.HelpText prettyText ->
                    let
                        plainText =
                            PP.toString prettyText
                    in
                    Expect.all
                        [ \{} -> Expect.equal True (String.contains (PP.toString testApp.intro) plainText)
                        , \{} -> Expect.equal True (String.contains testCmd.word plainText)
                        , \{} -> Expect.equal True (String.contains (PP.toString testApp.outro) plainText)
                        ]
                        {}

                _ ->
                    Expect.fail "--help didn't print help text"

        , test "If you don't pass a command, the help text is printed" <| \{} ->
            Expect.equal
                (runCommand testCmd [])
                (runCommand testCmd ["--help"])
        , test "The command name must match" <| \{} ->
            runCommand testCmd ["macbeth"]
                |> Expect.equal (Parser.UnknownCommand "macbeth")
        , describe "Args"
            [ test "Args in valid example is parsed correctly" <| \{} ->
                expectParseSuccess testCmd testArgs <| \cmd ->
                    Expect.equal
                        [ Path.fromPosixString "src/Main.gren" ]
                        cmd.args
            , test "Fails if passed arg fails the parser" <| \{} ->
                runCommand testCmdOneArg [ "make", "src/Main" ]
                    |> Expect.equal
                        (Parser.BadArguments <| Parser.ArgumentParserInvalidArgument)
            , describe "No args"
                [ test "Valid example parses to empty list when no args are passed" <| \{} ->
                    expectParseSuccess testCmd [ "make" ] <| \cmd ->
                        Expect.equal [] cmd.args
                , test "Passing no args when expecting none" <| \{} ->
                    expectParseSuccess testCmdNoArgs [ "make" ] <| \cmd ->
                        Expect.equal {} cmd.args
                , test "Passing args when expecting none" <| \{} ->
                    runCommand testCmdNoArgs testArgs
                        |> Expect.equal
                            (Parser.BadArguments <| Parser.ArgumentParserWrongArity 
                                { expected = 0
                                , actual = 1
                                }
                            )
                ]
            , describe "One arg" 
                [ test "Passing one arg when one is expected" <| \{} ->
                    expectParseSuccess testCmdOneArg testArgs <| \cmd ->
                        Expect.equal ( Path.fromPosixString "src/Main.gren" ) cmd.args
                , test "Passing no args when one is expected" <| \{} ->
                    runCommand testCmdOneArg [ "make" ]
                        |> Expect.equal
                            (Parser.BadArguments <| Parser.ArgumentParserWrongArity 
                                { expected = 1
                                , actual = 0
                                }
                            )
                , test "Passing multiple args when one is expected" <| \{} ->
                    runCommand testCmdOneArg [ "make", "src/Main.gren", "Example.gren" ]
                        |> Expect.equal 
                            (Parser.BadArguments <| Parser.ArgumentParserWrongArity 
                                { expected = 1
                                , actual = 2
                                }
                            )
                ]
            , describe "Zero or more args" 
                [ test "Multiple args" <| \{} ->
                    expectParseSuccess testCmd [ "make", "src/Main.gren", "src/Logic.gren" ] <| \cmd ->
                        Expect.equal
                            [ Path.fromPosixString "src/Main.gren"
                            , Path.fromPosixString "src/Logic.gren"
                            ]
                            cmd.args
                ]
            ]
        , describe "Flags"
            [ test "Flags in valid example are parsed correctly" <| \{} -> 
                expectParseSuccess testCmd testArgs <| \cmd ->
                    Expect.equal 
                        { debug = True
                        , output = Just <| Path.fromPosixString "out"
                        }
                        cmd.flags
            , test "Leaving out a flag means it's Nothing" <| \{} ->
                expectParseSuccess testCmd [ "make" ] <| \cmd ->
                    Expect.equal Nothing cmd.flags.output
            , test "Leaving out a toggle flag means it's false" <| \{} -> 
                expectParseSuccess testCmd (Array.filter (\f -> f /= "--debug") testArgs) <| \cmd ->
                    Expect.equal False cmd.flags.debug
            , test "Passing a toggle flag that is defined as value flag fails" <| \{} ->
                runCommand testCmd [ "make", "--output" ]
                    |> Expect.equal (Parser.BadFlags Parser.FlagParserMissingValue)
            , test "Passing a value flag without a set value fails" <| \{} ->
                runCommand testCmd [ "make", "--output=" ]
                    |> Expect.equal (Parser.BadFlags Parser.FlagParserMissingValue)
            , test "Passing a value flag where a toggle was expected fails" <| \{} ->
                runCommand testCmd [ "make", "--debug=true" ]
                    |> Expect.equal (Parser.BadFlags Parser.FlagParserFoundValueOnToggle)
            , test "Passing a flag that isn't recognized will return the appropriate error" <| \{} ->
                runCommand testCmd [ "make", "--hiya" ]
                    |> Expect.equal (Parser.BadFlags <| Parser.FlagParserUnknownFlag "hiya")
            , test "Passing --help will always output help text" <| \{} ->
                case runCommand testCmd [ "make", "--help" ] of
                    Parser.HelpText _ ->
                        Expect.pass

                    _ ->
                        Expect.fail "Expected help text"
            , test "Passing --help will output help text, even in the presence of other flags" <| \{} ->
                case runCommand testCmd [ "make", "--debug", "--help" ] of
                    Parser.HelpText _ ->
                        Expect.pass

                    _ ->
                        Expect.fail "Expected help text"
            ]
        ] 


testApp =
    { name = "my-program"
    , version = "1.1.0"
    , intro = PP.text "intro"
    , outro = PP.text "outro"
    , commands = Parser.defineGroup
    }


runCommand : Parser.Command args flags result -> Array String -> Parser.CommandParseResult result
runCommand cmd args =
    let
        parser =
            { testApp
                | commands =
                    Parser.defineGroup
                        |> Parser.withCommand cmd
            }
    in
    Parser.run args parser


expectParseSuccess : Parser.Command args flags result -> Array String -> (result -> Expectation) -> Expectation
expectParseSuccess cmd args next =
    case runCommand cmd args of
        Parser.Success result ->
            next result
        
        _ ->
            Expect.fail "Failed to parse"


testArgs : Array String
testArgs =
    [ "make", "--debug", "--output=out", "src/Main.gren" ]


testCmd =
    { word =
        "make"
    , arguments =
        Parser.zeroOrMoreArgs Parser.grenFileParser
    , flags =
        Parser.initFlags 
            (\debug output ->
                { debug = debug
                , output = output
                }
            )
            |> Parser.toggle "debug" "debug desc"
            |> Parser.flag "output" Parser.pathParser "output path"
    , commonDescription =
        Just "make your project"
    , summary =
        "Makey make make"
    , example = 
        PP.text "gren make src/Main.gren"
    , builder =
        \args flags ->
            { args = args
            , flags = flags
            }
    }

testCmdNoArgs =
    { word =
        "make"
    , arguments =
        Parser.noArgs
    , flags =
        Parser.initFlags 
            (\debug output ->
                { debug = debug
                , output = output
                }
            )
            |> Parser.toggle "debug" "debug desc"
            |> Parser.flag "output" Parser.pathParser "output path"
    , commonDescription =
        Just "make your project"
    , summary =
        "Makey make make"
    , example = 
        PP.text "gren make src/Main.gren"
    , builder =
        \args flags ->
            { args = args
            , flags = flags
            }
    }

testCmdOneArg =
    { word =
        "make"
    , arguments =
        Parser.oneArg Parser.grenFileParser
    , flags =
        Parser.initFlags 
            (\debug output ->
                { debug = debug
                , output = output
                }
            )
            |> Parser.toggle "debug" "debug desc"
            |> Parser.flag "output" Parser.pathParser "output path"
    , commonDescription =
        Just "make your project"
    , summary =
        "Makey make make"
    , example =
        PP.text "gren make src/Main.gren"
    , builder =
        \args flags ->
            { args = args
            , flags = flags
            }
    }
